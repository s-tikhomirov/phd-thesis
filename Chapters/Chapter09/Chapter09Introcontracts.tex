\chapter{Introduction to secure programming and smart contracts}

\label{Chapter09Introcontracts}

The notion of smart contracts have been first proposed by Nick Szabo in 1997.

Bitcoin offered for the first time a practical system to enforce agreements without a trusted third party.
However, Bitcoin script is deliberately limited.

Ethereum is a decentralized smart contracts platform~\cite{Buterin2014, Wood2014}.
Ethereum has been proposed as an implementation of a more complex programming environment based on the security guarantees of proof-of-work.
Ethereum full nodes store data, perform computations, and maintain consensus about the state of all accounts.

There is a number of key distinctions between Ethereum and Bitcoin.

First, Ethereum provides a richer programming environment.
An Ethereum nodes incorporates an instance of the \textit{Ethereum virtual machine} (EVM).
Developers write programs (smart contracts) in high-level languages that compile to EVM bytecode.
At publishing, each contracts is stored at a unique address.
In can be \textit{called} by users (using transactions) or by other contracts.
(The first contract in the call chain must be called with a transaction.)

Second, Ethereum is \textit{stateful}.
Ethereum nodes maintain consensus on the state of all accounts.
Each account can store units of the native crypto and, optionally, code and \textit{data} of a contract.
The code can react to transactions by sending ether or modifying the state (assigning new values to variables.)

Third, Ethereum implements an account-based model, as opposed to Bitcoin's UTXO-based one.
In Ethereum, balances are explicitly stored.
In Bitcoin, balances are calculated by wallet software by summing up all known UTXO values that are controlled by known private keys.

The richer programming capabilities  of Ethereum has benefits and drawbacks.
On the one hand, it enables applications that are difficult if not impossible to implement using Bitcoin.
(See \missing{Patrick paper} that compares the complexity of fair dice roll implementation in the two systems.)
This has fueled the crowdfunding (ICO) boom of~2017.
On the other hand, complexity has security implications.
A rich programming environment leaves more possibilities for programmers to make mistakes which are hard to fix.

This Part explores the security and privacy of Ethereum.
In this introductory Chapter, we give a technical overview of Ethereum and smart contract programming.



\section{Ethereum technical overview}

On a high level, the architecture of Ethereum is similar to that Bitcoin.
Mutually untrusted parties maintain consensus on a shared state using proof-of-work.
The integrity of the system is enabled by economic incentives.

Ethereum aims at not only encoding relatively simple value transfer, but more complex functionality.
Therefore, many implementation decisions have been made differently from Bitcoin.


\subsection{State and accounts}

Ethereum can be thought of as a state machine.
Nodes of the Ethereum peer-to-peer network maintain a shared view of the global state.
The state is a key-value mapping.
The key is an account address.
The value is the account \textit{state}.

There are two types of accounts in Ethereum.
The state of an account depends on its type.

\emph{Externally owned accounts} are controlled by a private key or by a smart contract.
\emph{Contract accounts} are controlled by a smart contract -- a piece of EVM bytecode.

Each account independent of its type has a \textit{nonce} and a \textit{balance}.
The \emph{nonce} stores the number of transactions sent by this account (for externally controlled accounts) or the number of contract creations made by this account (for contract accounts).
The \emph{balance} reflects the value the account owned in the Ethereum's native currency unit -- \textit{ether}.
Internally, balances are expressed in \emph{wei} -- the smallest denomination of ether.
1~ether = $10^{18}$~wei.

Contract accounts, in addition to nonce and balance, have \textit{code} (EVM bytecode) and \textit{storage} (a mapping of variable names to their current values).
Variables can be modified (if allowed by the code, but the code itself cannot.
Internally, data is stored in Merkle Patricia trees.
A Merkle Patricia tree is a radix tree optimized for key-value mappings with $256$-bit keys~\cite{MPTSpec, Buchman14}.


\subsection{Transactions and gas}

Ethereum users modify state by issuing transactions.
Each transaction represents a state transition.
Nodes validate and propagate transactions.
Miners validate and execute transactions, deriving the new global state.
They then perform proof-of-work based on the new state.

Ethereum contracts are written in a Turing complete language.
This means that in the general case it is impossible to determine whether a program would halt~\cite{Church1936}.
This allows for denial-of-service attacks.
An adversary could force miners to execute computationally demanding calculations.

To prevent resource abuse, the Ethereum protocol incorporates a pricing mechanism.
Every computational step in EVM is priced in units of \emph{gas}.
It makes resource-intensive computations in smart contracts economically infeasible.
EVM opcodes and their gas costs are defined in the Yellow paper~\cite{Wood2014}.
The price of a gas unit in ether is determined by the market.
For every transaction, the sender specifies the maximum amount of gas that the intended computation is expected to consume (the \emph{gas limit}) and the price the user wishes to pay per unit of gas (the \emph{gas price}).
The transaction fee equals the gas limit multiplied by the gas price.
If the execution is successful, the remaining ether is refunded.
If an error occurs, the transaction has no effect on the state, but all provided gas is consumed.
Miners can vote to gradually change the limit on the total amount of gas consumed in a block~\cite{Jnnk15}.
%Despite the EVM bytecode being Turing complete, all Ethereum computations are bound due to the gas mechanism.

A transaction is a signed data structure comprising a set of instructions to be atomically executed by the EVM.
It consists of the following fields:
\begin{itemize}
	\item \emph{nonce} -- the number of transactions sent by the sender;
	\item \emph{gasPrice} -- the number of wei per gas unit that the sender is paying;
	\item \emph{gasLimit} -- the maximum amount of gas to be spent during execution;
	\item \emph{to} -- the destination address (\texttt{0x0} for contract creation transactions);
	\item \emph{value} -- the number of wei transferred along with the transaction;
	\item \emph{v}, \emph{r}, \emph{s} -- signature data.
\end{itemize}

There are two types of transactions in Ethereum.
A \emph{message call transaction} executes a function of an existing contract or transfers ether.
It contains the arguments for the function call in an optional \emph{data} field.
A \emph{contract creation transaction} deploys a new contract.
It specifies the EVM bytecode of the new contract and the EVM code to be run once on contract creation.


\subsection{Block structure and mining}

Ethereum aims to substantially decrease time between blocks compared to Bitcoin.
Bitcoin blocks appear every $10$~minutes on average.
Ethereum generates blocks every $15$~seconds.
Without additional measures, such a short block interval would lead to a high orphan rate and wasted hash power.

Consider a block A with two child blocks B and B'.
Let us assume that the next block C is build on top of B.
In a simple protocol, the hash power spent on B' is wasted.
In a double-spend attack, the attacker would only have to re-generate the proof-of-work for A and B, while honest miners have spent their hash power to generate A, B, and B'.
The energy spent on orphan blocks does not contribute to security, decreasing the amount of work required for a double-spend.
This gives the attacker an advantage.
The shorter is the time between blocks, the more likely are accidental forks, which exacerbates the problem.

Therefore, Ethereum uses a modification of GHOST~\cite{Sompolinsky2013, EthdocsMining}.
GHOST is a blockchain protocol that accounts for the weight of valid but orphaned blocks when evaluating which chain is the heaviest~\cite{Wuille2017, Johnson2017}.
In the previous example, the miner of block C may include the hash of B' into C and get an additional reward.
The difficulty of B' would therefore count towards the weight of the branch A-B-C.

The block B' is refereed to as an \textit{uncle} block.
More formally, an uncle is a valid orphan blocks that is an ancestor of the current block.
Miners include hashed of uncles in block headers to receive additional reward.
Ethereum rewards uncles no more than 6~generations deep.
No more than $2$~uncles per block are allowed.
Miners of uncles whose headers get included in the main chain also receive additional reward.

Initially, Ethereum issued $5$~ether per block.
The issuance rate has been lowered to $3$~ether per block in 2017, and to $2$~ether per block in 2019.
Contrary to Bitcoin, Ethereum issuance rate is not hard-coded into the protocol~\cite{Ethhub2020}.
Changes in issuance are decided in an informal governance process and implemented by the core developers.

Ethereum uses a memory-hard hash function Ethash for PoW.
GPUs are a popular mining equipment, though ASICs have also been introduced.
%See~\cite{atomh33ls16} for a visual interpretation of the block structure in Ethereum.


\subsection{Applications}

Crowdfunding is arguably the first popular applications of smart contracts~\cite{McAdams2017}.
In 2017, the amount of money collected during so-called initial coin offerings (ICO) skyrocketed, reaching \$1.8~bn~\cite{CoindeakICOTracker} and surpassing early stage venture capital funding~\cite{Sunnarborg2017}.
ICO is usually based around a token -- a smart contract that maintains a list of users' balances and allows them to transfer tokens or buy and sell them for ether.
Tokens are usually implemented with respect to the API defined in the ERC20 standard~\cite{Victor2019}.
The ICO organizers often promise that the tokens will be required to use the to-be developed product or service.
While many ICOs were dubious projects or outright scams, Ethereum proved to be a useful tool for global crowdfunding.

In 2019, a new are of smart contract application appeared under the name of \textit{decentralized finance}, or \textit{DeFi}.
DeFi projects aim to implement building blocks of traditional finance, such as loans, on Ethereum.
The basic building block for DeFi is a \textit{stablecoin} -- a token with the value linked to the US~dollar.
A prominent stablecoin project is MakerDAO.

Other potential applications of Ethereum include decentralized file storage~\cite{Storj} and computation~\cite{Golem}, name systems~\cite{ENS}, and prediction markets~\cite{Augur, Gnosis}.


\section{Smart contract programming}

EVM bytecode is a low-level Turing complete stack-based language operating on 256-bit words designed to be simple compared to general purpose VMs like JVM, execute deterministically, and natively support cryptographic primitives~\cite{Buterin2017}.
Developers usually write contracts in high-level languages targeting EVM, the most popular one being Solidity~\cite{Solidity17} -- a statically typed language with a Javascript-like syntax.
Others include Serpent~\cite{SerpentGithub} (deprecated in 2017~\cite{Castor2017}) and LLL~\cite{Ellison2017} (Python- and Lisp-like syntax respectively).

\begin{lstlisting}[language=Solidity, caption=A simple contract in Solidity]
pragma solidity 0.4.17;
contract StringStorageContract {
string private str = "Hello, world!";
function getString() public constant returns (string) {
return str;
}
function setString(string _str) public {
str = _str;
}
}
\end{lstlisting}

Security is of paramount importance in smart contract programming~\cite{Atzei2017, Delmolino2016}.
Contrary to traditional software, smart contracts can not be patched, which brings new challenges to blockchain programming~\cite{Porru2017}.
Multiple approaches exist to contract programming~\cite{Seijas2016}.
Areas of research in this domain include systematizing good and bad programming practices~\cite{ConsenSys16, Chen2017}, designing general-purpose~\cite{Hirai2017a, Buterin2017b, Pettersson2016} as well as domain-specific~\cite{Biryukov2017, EgelundMueller2017} smart contract programming languages, and developing tools for automated security analysis~\cite{Luu2016a, Tsankov2018} and formal verification~\cite{Bhargavan2016} of smart contract source code, EVM bytecode, and the EVM itself~\cite{Hirai2017}.

An important challenge is to describe smart contracts' execution model (possibly drawing parallels from concurrent programming on a multi-threaded processor~\cite{Sergey2017}) and to develop a usable and formally verifiable high-level language reflecting this model.
Some argue that Solidity inclines programmers towards unsafe development practices~\cite{ydtm2016}.
Typical vulnerabilities and issues in Solidity might include:
\begin{enumerate}
	\item \textbf{Re-entrancy}. Contracts can call each other. Malicious external contracts can call the caller back. If the victim contract does its internal bookkeeping after returning from an external call, its integrity can be compromised\footnote{This bug led to the DAO hack of 2016.}.
	\item \textbf{Miner's influence}. Miners can to some extend influence execution (front-running, censorship, or altering environmental variables, e.g.,~timestamp).
	\item \textbf{Out-of-gas exceptions}. Computation in Ethereum is many orders of magnitude more expensive than with centrally managed cloud computing services. Developers who do not take it into account may implement functions that require too much gas to fit in the block gas limit and thus always fail.
\end{enumerate}

\subsubsection*{Trusted data sources}
Many smart contract applications (financial derivatives, insurance, prediction markets) depend on real-world data.
Ethereum is isolated from the broader Internet to guarantee consistent execution across nodes.
A popular approach to providing data to contracts in a trust-minimizing way is an oracle -- a specialized data provider, possibly with a dedicated cryptographic protocol to guarantee integrity~\cite{Provable}.
A recent development is TownCrier -- an oracle built with trusted hardware~\cite{Zhang2016}.

\subsubsection*{Gas pricing}
Though the gas price in ether is determined by the market, the relative gas costs of EVM bytecodes are constant.
In September~2016, an attacker exploited a weakness in gas pricing and organized a DoS attack on the network, taking advantage of the fact that certain operations were under-priced~\cite{EIP150}.
The problem was ultimately fixed with a hard fork.
Research is needed to propose more flexible mechanisms for determining relative prices of EVM operations.

\subsubsection*{Responsible disclosure and contract patching}
Information security researchers usually adhere to the "responsible disclosure" policy: they report a bug privately to the vendor and give developers time to fix it before publishing the information in the open.
Though some oppose this practice~\cite{Schneier2007}, it is assumed to decrease the probability of an attack on the live system (unless the attackers discover the same bug independently before a patch is applied).
Ethereum introduces a new dimension to the responsible disclosure debate, as smart contracts can not be patched.
It is unclear whether it is ethical to fully disclose a vulnerability discovered in a smart contract, if developers can not fix it anyway\footnote{A technical response to this issue could be updateable contracts: users communicate with a proxy contract, which redirects their transactions to the latest version of the main contract. Such scheme assumes that the developers are honest and competent so that the latest update does not run away with everyone's money.}.
