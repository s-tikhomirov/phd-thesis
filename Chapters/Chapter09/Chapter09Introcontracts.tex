\chapter{Introduction to secure programming and smart contracts}

\label{Chapter09Introcontracts}

A contract is a basic building block of market economy.
Despite significant changes in legal systems, the foundational mechanics of a contract has not changed in centuries.
It is usually a written text which is designed to be interpreted by humans.

The rapid evolution of electronic commerce has made the current implementation of a contract outdated.
Humans who write and interpret contracts can hardly keep up with the increased speed and complexity of international commerce.

In an influential 1997 essay~\cite{Szabo1997}, Nick Szabo coined the term \textit{smart contract}.
He argued that "contractual clauses [...] can be embedded in the hardware and software [...] to make breach of contract expensive".
A classic example of a "primitive ancestor" of a smart contract is a vending machine.
A machine receives coins and distributes goods and change according to the listed price.
The physical properties of the machine make attacking it sufficiently expensive to be unprofitable.
However, a contract implemented by a vending machine is automated but not trustless.
The supplier possesses the administrator key and has a privileged access to the money and goods in the machine.

The idea of smart contracts remained dormant until Bitcoin.
Bitcoin, for the first time, enabled smart contracts without an administrator.
Bitcoins can only be unlocked by providing the required arguments to their respective output scripts.
This has lead to discussions in the Bitcoin community on the possibilities of implementing a wide range of smart contracts based on Bitcoin.
Early Bitcoin-based protocols towards this goal include Colored Coins, Counterparty, and Mastercoin~\cite{Rosenfeld2012,Willett2016,Bartoletti2017a}.

Bitcoin's programming capabilities are too restrictive to encode many types of contracts.
First, Bitcoin script is not Turing-complete.
It means, for instance, that it does not support loops.
Second, Bitcoin contracts lack the ability to access other contracts.
Each transaction is executed in isolation and can either be deemed correct or not.
It is impossible to branch depending on the results of executing another transaction.
On the one hand, such limitations limit the potential attack surface and simplify security analysis.
On the other hand, they make implementing many types of contracts difficult, if not impossible~\cite{Miller2019}.

Ethereum was created to address these limitations.
It provides a platform for more complex smart contracts without a trusted third party.
Ethereum was announced by Vitalik Buterin in 2014~\cite{Buterin2014, Wood2014} and launched in 2015.

There are three key differences between Ethereum and Bitcoin.

First, Ethereum provides a richer programming environment.
Ethereum smart contracts are stored at unique addresses.
They can be called by users or by other contracts.
This interoperable ecosystem allows creating contracts that interact with each other.

Second, Ethereum is \textit{stateful}.
Ethereum maintains consensus on the state of all accounts.
This allows for storing the results of a contract execution on-chain.
The effect of a transaction may be changing balances or state variables of multiple accounts.
An Ethereum transaction can affect multiple accounts, changing their balances and states.
(In contrast to Bitcoin, where the result of a transaction is binary: either the UTXOs are spent or not.)

Third, Ethereum implements an account-based model (as opposed to Bitcoin's UTXO-based one).
This simplifies the contract logic.
Instead of scanning the whole history to infer the current balance of an address, a contract performs a single lookup.

Bitcoin and Ethereum represent different points in the blockchain design space.
The differences between these two dominant open blockchain networks are often a subject of heated debate.
Some proponents of Bitcoin are eager to point out the questionable architectural decisions in the core Ethereum protocol and the vulnerabilities discovered in Ethereum smart contracts.
Members of the Ethereum community emphasize a faster evolution of Ethereum and a wider range of applications it enables.

Simple systems are usually more secure than complex ones.
The more interactions parts of the system engage in, the more of the can potentially go wrong or be purposefully exploited.
Ethereum contacts is a case in point.
A rich programming environment leaves more possibilities for programmers to make mistakes which are hard to fix.
Multiple high-profile smart contracts were hacked or broken, losing on the order of tens and sometimes hundreds of millions of US~dollars.
These unfortunate events have shown that secure programming practices are especially important for smart contracts.

In this Part, we explore the security and privacy of Ethereum smart contracts.


\section{Ethereum architecture}

\subsection{Accounts}

Ethereum can be thought of as a state machine.
Ethereum nodes communicate through a peer-to-peer network to and maintain a shared view of the global state.
The state reflect the state of all \textit{accounts}.
It maps account \textit{addresses} to account \textit{states}.

There are two types of accounts in Ethereum: externally owned accounts and contract accounts.
An \textit{externally owned account} is controlled by a private key.
A \textit{contract account} is controlled by a \textit{smart contract} -- a piece of EVM bytecode.
Each account has a \textit{balance} -- the amount of the native cryptocurrency \textit{ether} controlled by this account.
Internally, balances are expressed in \textit{wei} -- the smallest denomination of ether.
1~ether = $10^{18}$~wei.

Apart from balance, contract accounts have \textit{code} and \textit{storage}.
Contract code is a piece of EVM bytecode.
Contract storage is a mapping of arbitrary variable names to their values.
The contract code controls all changes to the balance and storage of the account.
\footnote{There are exceptions: the balance of any account can be increased by mining to it or by transferring the balance of another contract being destroyed with the \texttt{selfdestruct} operation.}
Internally, account data is stored in Merkle Patricia trees -- radix trees with $256$-bit keys~\cite{MPTSpec, Buchman14}.
The storage of a contract account can be modified (if allowed by its code), but the code itself cannot.


\subsection{Transactions}

Users interact with Ethereum by issuing \textit{transactions}.
A transaction represents a proposed state transition.
There are two types of transactions in Ethereum.
A \textit{message call transaction} executes a function of an existing contract or transfers ether.
It contains the arguments for the function call in an optional \textit{data} field.
A smart contract function called by a transaction can in turn other functions in this or other contracts.
A \textit{contract creation transaction} deploys a new contract.
It specifies the code of the new contract and the code to be run once on contract creation.

Transactions incur fees to prevent resource abuse.
Every computational step in EVM is priced in units of \emph{gas}.
A transaction sender specifies the \textit{gas limit} and the \textit{gas price}.
The \textit{gas limit} is the maximum amount of gas that the transaction is allowed to consume.
The \textit{gas price} is the amount of ether the sender wants to pay per unit of gas consumed.
Therefore, the maximum transaction fee (in ether) equals the gas limit multiplied by the gas price.
If the execution is successful, the remaining ether is refunded.

EVM executes transactions \textit{atomically}.
A failed transaction has no effects, but consumes all provided gas.

Ethereum specification (the Yellow paper~\cite{Wood2014}) defines gas costs of EVM opcodes.
Developers occasionally change them in protocol upgrades (implemented as hard forks).
The market determines the price of a gas unit in ether
The \textit{block gas limit} bounds the amount of gas consumed in one block.
Miners can vote to gradually change this limit~\cite{Jnnk15}.

A transaction includes the following fields:
\begin{itemize}
	\item \emph{nonce} -- the number of transactions sent by the sender;
	\item \emph{gasPrice} -- the number of wei per gas unit that the sender is paying;
	\item \emph{gasLimit} -- the maximum amount of gas to be spent during execution;
	\item \emph{to} -- the destination address (\texttt{0x0} for contract creation transactions);
	\item \emph{value} -- the number of wei transferred along with the transaction;
	\item \emph{v}, \emph{r}, \emph{s} -- signature data.
\end{itemize}



\subsection{Mining and coin issuance}

Ethereum uses proof-of-work as a Sybil resistance mechanism.
Ethereum miners pick unconfirmed transactions from the P2P network, serialize them, and apply them to the current state.
They then perform proof-of-work based on the new state.
Ethereum uses a memory-hard hash function Ethash for PoW~\cite{Ethash}.
Miners often use GPUs, though ASICs have also been introduced.

Miners are rewarded with transaction fees and block subsidy.
Initially, Ethereum issued $5$~ether per block.
The issuance rate decreased to $3$~ether per block in 2017, and to $2$~ether per block in 2019.
Contrary to Bitcoin, Ethereum issuance rate is not hard-coded into the protocol~\cite{Ethhub2020}.
Changes in issuance are decided in an informal governance process and implemented by the core developers.

Ethereum aims at a short average interval between blocks: $15$~seconds, compared to $10$~minutes in Bitcoin.
Short block intervals lead to a high \textit{orphan rate}.
An \textit{orphan} is a valid block that did not get accepted in the main chain.
Network delays lead to miners unwillingly generating multiple blocks on the same height.
Only one of these block is eventually accepted, others become orphans.
The hash power spent on orphans is essentially wasted.
In a double-spend attack, the attacker would only have to re-generate the PoW for the main chain, but not for orphan blocks.
Short time between blocks exacerbates this problem.

To address the issue, Ethereum uses a modification~\cite{Lewenberg2015} of GHOST protocol~\cite{Sompolinsky2013, EthdocsMining}.
%This blockchain protocol accounts for the weight of orphaned blocks~\cite{Wuille2017, Johnson2017}.
In Ethereum, orphans are refereed to as an \textit{uncle} blocks.
Ethereum miners include hashes of orphan blocks (also referred to as \textit{uncles}) in block headers to receive additional reward.
Ethereum rewards uncles no more than $6$~blocks old.
No more than $2$~uncles per block are allowed.
Miners of uncles whose headers get included in the main chain are also rewarded.


\subsection{Contracts}

Solidity~\cite{Solidity17} is the most popular high-level language for Ethereum smart contracts.
\footnote{An alternative language which is in earlier stage of development is Vyper~\cite{Vyper}. Other alternative high-level languages, such as Serpent~\cite{SerpentGithub} and LLL~\cite{Ellison2017}, have been largely abandoned.}
It is a a statically typed language with a Javascript-like syntax.
Listing~\ref{lst:SolidityExample} provides an example of a program in Solidity.

Developers compile Solidity code into EVM bytecode and deploy it.
Users then interact with it by issuing transactions.

Ethereum nodes execute contract bytecode on the \textit{Ethereum virtual machine} (EVM).
EVM bytecode is a low-level Turing complete stack-based language operating on 256-bit words.
EVM is designed with other goals in mind compared to general- purpose virtual machines such as the Java virtual machine (JVM).
For instance, EVM executes deterministically (otherwise consensus would be impossible) and natively supports relevant cryptographic operations~\cite{Buterin2017}.

\begin{lstlisting}[language=Solidity, label={lst:SolidityExample}, caption=A simple contract in Solidity]
pragma solidity 0.4.17;
contract StringStorageContract {
string private str = "Hello, world!";
function getString() public constant returns (string) {
return str;
}
function setString(string _str) public {
str = _str;
}
}
\end{lstlisting}


\subsection{Applications}

Crowdfunding is arguably the first popular applications of smart contracts~\cite{McAdams2017}.
This was exemplified with the so-called \textit{initial coin offering} (ICO) boom in 2017.
An ICO is usually based on a token -- an cryptocurrency built on top of Ethereum.
A token is usually implemented as a smart contract that maintains a list of users' current balances.
Users can transfer tokens by interacting with the contract.
The de-facto standard way to implement a token is the ERC20 standard~\cite{Victor2019}.

In 2017, the total amount of ICO funding reached~\$1.8~bn~\cite{CoindeakICOTracker} and surpassed early stage venture capital funding~\cite{Sunnarborg2017}.
It is worth noting that many ICOs supported dubious projects or outright scams.
However, Ethereum proved useful as a global crowdfunding platform.

In 2019, another category of Ethereum-based applications known as \textit{decentralized finance}, or \textit{DeFi}, gained momentum.
DeFi projects try to replicate traditional financial services, such as loans, in a more trustless way.
The basic building block for DeFi is a \textit{stablecoin} -- a token with the value linked to the US~dollar.
MakerDAO is a prominent stablecoin project.
Other popular DeFi projects, as of 2020, include Uniswap (a decentralized exchange) and Compound (a lending platform).

Potential applications of Ethereum also include decentralized file storage~\cite{Storj} and computation~\cite{Golem}, name systems~\cite{ENS}, and prediction markets~\cite{Augur, Gnosis}.


\section{Challenges for smart contract security}

In 2016, a high-profile Ethereum contract called \textit{The DAO} was broken into~\cite{Sirer2016}.
An unknown hacker appropriated around $40$~million~USD worth of ether.
Ethereum developers proposed a non backwards-compatible protocol upgrade to return the funds.
This was a controversial move, because the EVM behaved correctly.
It was the faulty contract code that caused the calamity.
Most community members accepted the proposal.
A dissident minority continued to support the original chain (Ethereum~Classic~\cite{EthereumClassic}).

\textit{The DAO} incident showed the importance of secure smart contract development.
Let us list some of the most pressing security challenges in this area.
We refer the reader to~\cite{Delmolino2016, Atzei2017} for an overview of attacks on smart contracts.

\subsection{Smart contract semantics}
Smart contracts must precisely reflect the intent of the developers.
This may not always be the case in practice.
Smart contract programming languages, such as Solidity, are unfamiliar to developers.
Some argue that Solidity itself inclines programmers towards unsafe development practices~\cite{ydtm2016}.
Moreover, the actual Ethereum network executes bytecode, not Solidity code.
The security thus depends on the compiler and the EVM runtime environment.
Approaches to address these issues include:
\begin{itemize}
	\item systematizing good and bad programming practices~\cite{ConsenSys16, Chen2017};
	\item designing general-purpose~\cite{Hirai2017a, Buterin2017b, Pettersson2016} as well as domain-specific~\cite{Biryukov2017, EgelundMueller2017} smart contract programming languages;
	\item formalizing smart contracts execution model~\cite{Sergey2017};
	\item developing tools for automated security analysis~\cite{Luu2016a, Tsankov2018};
	\item of smart contract source code, EVM bytecode, and the EVM itself~\cite{Bhargavan2016, Hirai2017}.
\end{itemize}

See~\cite{Seijas2016} for an overview of approaches to smart contract programming.

\subsection{Bug-fixing and updates}
Smart contracts can not be patched.
This presents an inherent trade-off~\cite{Porru2017}.
On the one hand, smart contracts should guarantee fairness.
Ideally, after a contract is deployed, nobody should be able modify its code, even its developers.
This ensures that privileged parties cannot unexpectedly change the rules of the game in their favor.
On the other hand, smart contracts are experimental software.
Deployed contracts are likely to contain bugs.
An adversary can then exploit contract vulnerabilities without restraint.
\footnote{This introduces a new dimension into the debate on responsible disclosure~\cite{Schneier2007}. It is ethical to publicly disclose a smart contact vulnerability, if the developers have no technical means to fix it?}
Real-world projects often address this issue by encoding an administrator key in their contracts.
The owner of this key can perform a limited number of actions.
For example, an administrator might be able to pause withdrawals without the ability to steal users' funds.

\subsection{External data sources}
Some smart contract rely on external data to operate.
A large portion of potential use cases envisions smart contracts that depend on the data from the "real world", e.g.,~financial quotes.
External information can only get into a smart contract from a transaction.
Centralized data providers (also known as \textit{oracles}) constitute a potential point of failure.
This issue is known as the \textit{oracle problem}.
Multiple designs of trust-minimized oracles have been proposed.
Mechanisms to ensure data authenticity include TLS-based cryptographic guarantees~\cite{Provable}, trusted hardware~\cite{Zhang2016}, and economic incentives~\cite{Chainlink}.

\subsection{Front-running and miner influence}
Miners determine which transactions and in which order are included in a block.
For certain applications, such as trading, transaction ordering is crucial.
Miners and other users are incentivized to engage in \textit{front-running}: prioritizing their own transactions at the expense of others.
It has been shown that automated bots do perform front-running in Ethereum-based decentralized exchanges~\cite{Daian2019}.

\subsection{Privacy}
Smart contacts introduce new privacy issues.
Ethereum architecture has good and bad effects on privacy.
On the one hand, Ethereum's account-based model inclines users to perceive their Ethereum address as their semi-permanent identity.
This harms privacy.
On the other hand, richer programming capabilities enable sophisticated privacy solutions built as Ethereum smart contracts.
For instance, the possibility to verify zero-knowledge proofs on-chain enabled the development of advanced privacy protocols such as Aztec~\cite{Aztec} and Tornado Cash~\cite{TornadoCash}.

