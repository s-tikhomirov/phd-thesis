\chapter{Introduction to secure programming and smart contracts}

\label{Chapter09Introcontracts}

Ethereum is a major blockchain-based platform for smart contracts -- Turing complete programs that are executed in a decentralized network and usually manipulate digital units of value.
A peer-to-peer network of mutually distrusting nodes maintains a common view of the global state and executes code upon request.
The stated is stored in a blockchain secured by a proof-of-work consensus mechanism similar to that in Bitcoin.
The core value proposition of Ethereum is a full-featured programming language suitable for implementing complex business logic.

Decentralized applications without a trusted third party are appealing in areas like crowdfunding, financial services, identity management, and gambling.
Smart contracts are a challenging research topic that spans over areas ranging from cryptography, consensus algorithms, and programming languages to governance, finance, and law.

This paper summarizes the state of knowledge in this field.
In this Chapter, we provide a technical overview of Ethereum, and outline some of the open challenges.

Ethereum is a decentralized smart contracts platform~\cite{Buterin2014, Wood2014}.
Ethereum full nodes store data, perform computations, and maintain consensus about the state of all accounts using a proof-of-work mechanism similar to that in Bitcoin.
Programs (Ethereum smart contracts) are stored on the blockchain as Ethereum virtual machine (EVM) bytecode, a Turing-complete language.
Programmers write contracts in high-level languages targeting EVM, most popular being Solidity and Serpent (we use the former).

A contract can call other contracts' functions and send them units of Ether -- the Ethereum native cryptocurrency.
To launch a particular function of a contract, a user must send a well-formed transaction to the Ethereum network.

Each EVM operation has a fixed cost in \textit{gas}.
A user pays upfront for the maximum amount of gas the computation is expected to consume and gets a partial refund after a successful execution.
If an exception (including "out of gas") occurs, all changes are reverted, but the gas is not refunded.



\section{Ethereum technical overview}

\subsection{State and accounts}
Ethereum can be thought of as a state machine.
Nodes of the Ethereum peer-to-peer network maintain a shared view of the global state.
A user interacts with the network by issuing a transaction representing a valid state transition.
Nodes pick transactions from the \emph{mempool} (the set of unconfirmed transactions), verify their validity, perform the corresponding computation (possibly changing ownership of units of the Ethereum native cryptocurrency \emph{ether}), and update the state.
There are two types of accounts in Ethereum: \emph{externally owned accounts} and \emph{contract accounts} controlled by a private key or by a smart contract -- a piece of code deployed on the blockchain -- respectively.

The account state consists of the following fields:
\begin{itemize}
	\item \emph{nonce} -- the number of transactions sent by this account (for externally controlled accounts) or the number of contract creations made by this account (for contract accounts);
	\item \emph{balance} -- the number of \emph{wei}\footnote{Smallest denomination of ether: 1~ether = $10^{18}$~wei.} owned by this account;
	\item \emph{storageRoot} -- Merkle Patricia tree root of this account's storage;
	\item \emph{codeHash} -- hash of this account's contract bytecode.
\end{itemize}

Accounts' 160-bit addresses\footnote{Addresses are usually written in hex with a \texttt{0x} prefix.} are derived from its public key or, in case of contract accounts, from the address of the contract's creator and its nonce~\cite{EthereumSE16}.
The global state maps addresses to account states.
The primary data structure in Ethereum is the Merkle Patricia tree -- a radix tree optimized for key-value mappings with 256 bit keys~\cite{MPTSpec, Buchman14}.
The root hash authenticates the whole data structure.
Values pairs are editable in logarithmic time.

The Ethereum state model (accounts and states) differs from than in Bitcoin.
The Bitcoin blockchain stores unspent transaction output (UTXO); balances of addresses are calculated off-chain by wallet software.


\subsection{Transactions and gas}

The halting problem -- determining if a given program will ever halt -- is unsolvable in the general case~\cite{Church1936}.
This poses a challenge: nodes running the Ethereum virtual machine (EVM) cannot foresee the amount of resources required for validating a transaction, which enables denial-of-service attacks.

To overcome the issue, the Ethereum protocol incorporates a pricing mechanism.
It makes resource-intensive computations in smart contracts economically infeasible.
Every computational step in EVM is priced in units of \emph{gas}.
EVM opcodes and their gas costs are defined in the Yellow paper~\cite{Wood2014}.
The price of a gas unit in ether is determined by the market.
For every transaction, the sender specifies the maximum amount of gas that the intended computation is expected to consume (the \emph{gas limit}) and the price the user wishes to pay per unit of gas (the \emph{gas price}).
The transaction fee equals the gas limit multiplied by the gas price.
If the execution is successful, the remaining ether is refunded.
If an error occurs, the transaction has no effect on the state, but all provided gas is consumed.
Miners can vote to gradually change the limit on the total amount of gas consumed in a block~\cite{Jnnk15}.
%Despite the EVM bytecode being Turing complete, all Ethereum computations are bound due to the gas mechanism.

A transaction is a signed data structure comprising a set of instructions to be atomically executed by the EVM.
It consists of the following fields:
\begin{itemize}
	\item \emph{nonce} -- the number of transactions sent by the sender;
	\item \emph{gasPrice} -- the number of wei per gas unit that the sender is paying;
	\item \emph{gasLimit} -- the maximum amount of gas to be spent during execution;
	\item \emph{to} -- the destination address (\texttt{0x0} for contract creation transactions);
	\item \emph{value} -- the number of wei transferred along with the transaction;
	\item \emph{v}, \emph{r}, \emph{s} -- signature data.
\end{itemize}

There are two types of transactions in Ethereum.
A \emph{contract creation transaction} is used to deploy a new contract.
It contains an additional \emph{init} field that specifies the EVM code to be run on contract creation, as well as the EVM code of the new contract.
A a \emph{message call transaction} is used to execute a function of an existing contract (with arguments specified by the an optional \emph{data} field) or to transfer ether.


\subsection{Block structure and mining}
Ethereum uses proof-of-work (PoW): nodes compete to find a partial collision of a cryptographic hash function and produce the next block\footnote{See~\cite{atomh33ls16} for a visual interpretation of the block structure in Ethereum.}.
Both Bitcoin~\cite{Wuille2017} and Ethereum~\cite{Johnson2017} chose the \textit{heaviest} chain as a valid one in case of forks, where a chain's \textit{weight} is defined as the sum of its blocks' difficulties.

Good connectivity is crucial for Bitcoin mining operation: the resources spent mining on a block other than the latest one are essentially wasted.
Good connectivity puts big pools at an advantage, while blocks from worse connected miners propagate slowly and increase the orphan rate.
Thus Bitcoin mining is prone to centralization.
To be able to operate with block times much shorter than Bitcoin's 10~minutes (about 30~seconds in September~2017), Ethereum uses a mining protocol~\cite{EthdocsMining} similar to GHOST~\cite{Sompolinsky2013}.
Ethereum considers \emph{uncles} -- valid orphan blocks that are ancestors of the current block (no more than 6~generations deep).
For each block, the miner receives a static reward of 5~ether, payments for the gas consumed by transactions in the block, and $1/32$ of the static reward ($0.15625$~ether) per uncle, whose hash is included in the block header (no more than 2~uncles per block).
Miners of uncles whose headers get included in the main chain receive $7/8$ of the static reward ($4.375$~ether).
Due to uncles, the energy spent on orphan blocks contributes to security, increasing the amount of work required for a double-spend.

Contrary to Bitcoin, where coins are issued on a diminishing rate with a total cap of 21~million, Ethereum issues ethers at a constant rate with no total cap.
Ethereum's issuance parameters may change after switching to proof-of-stake (see Section~\ref{Consensus}).

Bitcoin PoW uses a general purpose cryptographic hash function SHA-256, which can be efficiently implemented in hardware.
Specialized mining equipment (application-specific integrated circuits, ASIC) is orders of magnitude more efficient than commodity hardware, which puts small miners at a disadvantage.
Ethereum uses a memory hard hash function Ethash and targets GPUs as the primary mining equipment.
It helps prevent mining centralization akin to Bitcoin's and throttles CPU mining (botnets or cloud VM instances can be rented for a short time to perform an attack).
%In mid~2017, due to increased demand for high-end GPUs for mining, major GPU producers introduced specialized mining GPUs~\cite{Haig17}.

Table~\ref{table:1} compares some properties of Bitcoin and Ethereum.
Note that the practical requirements regarding the disk space for an Ethereum node can be greatly reduced due to the explicit storage of account balances and data as opposed to Bitcoin's UTXO~\cite{EthereumSEDiskSpace}.

\begin{table}[ht]
	\centering
	\begin{tabular}{|p{0.40\linewidth}|p{0.30\linewidth}|p{0.30\linewidth}|}
		\hline
		\textbf{Metric} & \textbf{Bitcoin} & \textbf{Ethereum} \\
		\hline\hline
		Number of nodes & 9428 & 22007 \\
		\hline
		Blockchain size & 158~GB & 52~GB \\
		\hline
		Transactions per hour & 8509 & 12406 \\ 
		\hline
		Market capitalization (\$~million) & 62812 & 27200 \\
		\hline
		Daily trading volume (\$~million) & 997 & 420 \\
		\hline
	\end{tabular}
	\caption{Bitcoin and Ethereum, September~2017~\cite{Etherchain17, Bitnodes17, Ethernodes17, Bitinfocharts17, Coinmarketcap17}}
	\label{table:1}
\end{table}

\subsection{Applications}
Among many potential applications of smart contracts~\cite{McAdams2017}, crowdfunding is arguably the first widely successful one.
The first wide-scale Ethereum-based crowdfunding project was a decentralized investment fund called The DAO, launched on 30~April~2016\footnote{In June 2016, an unknown hacker exploited a vulnerability in the DAO code and withdrew around \$50 million, leading to a controversial~\cite{ETCDeclaration} hard fork.}.
In 2017, the amount of money collected during so-called initial coin offerings (ICO) skyrocketed, reaching \$1.8~bn~\cite{CoindeakICOTracker} and surpassing early stage venture capital funding~\cite{Sunnarborg2017}.
ICO is usually based around a token -- a smart contract that maintains a list of users' balances and allows them to transfer tokens or buy and sell them for ether.
Tokens are usually implemented with respect to the API defined in the ERC20 standard~\cite{Victor2019}.
The ICO organizers often promise that the tokens will be required to use the to-be developed product or service.
Prominent Ethereum applications include decentralized file storage~\cite{Filecoin} \cite{Sia} \cite{Storj} and computation~\cite{Golem} \cite{Sonm}, name systems~\cite{ENS}, and prediction markets~\cite{Augur} \cite{Gnosis}.


\section{Smart contract programming}

EVM bytecode is a low-level Turing complete stack-based language operating on 256-bit words designed to be simple compared to general purpose VMs like JVM, execute deterministically, and natively support cryptographic primitives~\cite{Buterin2017}.
Developers usually write contracts in high-level languages targeting EVM, the most popular one being Solidity~\cite{Solidity17} -- a statically typed language with a Javascript-like syntax.
Others include Serpent~\cite{SerpentGithub} (deprecated in 2017~\cite{Castor2017}) and LLL~\cite{Ellison2017} (Python- and Lisp-like syntax respectively).

\begin{lstlisting}[language=Solidity, caption=A simple contract in Solidity]
pragma solidity 0.4.17;
contract StringStorageContract {
string private str = "Hello, world!";
function getString() public constant returns (string) {
return str;
}
function setString(string _str) public {
str = _str;
}
}
\end{lstlisting}

Security is of paramount importance in smart contract programming~\cite{Atzei2017, Delmolino2016}.
Contrary to traditional software, smart contracts can not be patched, which brings new challenges to blockchain programming~\cite{Porru2017}.
Multiple approaches exist to contract programming~\cite{Seijas2016}.
Areas of research in this domain include systematizing good and bad programming practices~\cite{ConsenSys16, Chen2017}, designing general-purpose~\cite{Hirai2017a, Buterin2017b, Pettersson2016} as well as domain-specific~\cite{Biryukov2017, EgelundMueller2017} smart contract programming languages, and developing tools for automated security analysis~\cite{Luu2016a, Tsankov2018} and formal verification~\cite{Bhargavan2016} of smart contract source code, EVM bytecode, and the EVM itself~\cite{Hirai2017}.

An important challenge is to describe smart contracts' execution model (possibly drawing parallels from concurrent programming on a multi-threaded processor~\cite{Sergey2017}) and to develop a usable and formally verifiable high-level language reflecting this model.
Some argue that Solidity inclines programmers towards unsafe development practices~\cite{ydtm2016}.
Typical vulnerabilities and issues in Solidity might include:
\begin{enumerate}
	\item \textbf{Re-entrancy}. Contracts can call each other. Malicious external contracts can call the caller back. If the victim contract does its internal bookkeeping after returning from an external call, its integrity can be compromised\footnote{This bug led to the DAO hack of 2016.}.
	\item \textbf{Miner's influence}. Miners can to some extend influence execution (front-running, censorship, or altering environmental variables, e.g.,~timestamp).
	\item \textbf{Out-of-gas exceptions}. Computation in Ethereum is many orders of magnitude more expensive than with centrally managed cloud computing services. Developers who do not take it into account may implement functions that require too much gas to fit in the block gas limit and thus always fail.
\end{enumerate}

\subsubsection*{Trusted data sources}
Many smart contract applications (financial derivatives, insurance, prediction markets) depend on real-world data.
Ethereum is isolated from the broader Internet to guarantee consistent execution across nodes.
A popular approach to providing data to contracts in a trust-minimizing way is an oracle -- a specialized data provider, possibly with a dedicated cryptographic protocol to guarantee integrity~\cite{Provable}.
A recent development is TownCrier -- an oracle built with trusted hardware~\cite{Zhang2016}.

\subsubsection*{Gas pricing}
Though the gas price in ether is determined by the market, the relative gas costs of EVM bytecodes are constant.
In September~2016, an attacker exploited a weakness in gas pricing and organized a DoS attack on the network, taking advantage of the fact that certain operations were under-priced~\cite{EIP150}.
The problem was ultimately fixed with a hard fork.
Research is needed to propose more flexible mechanisms for determining relative prices of EVM operations.

\subsubsection*{Responsible disclosure and contract patching}
Information security researchers usually adhere to the "responsible disclosure" policy: they report a bug privately to the vendor and give developers time to fix it before publishing the information in the open.
Though some oppose this practice~\cite{Schneier2007}, it is assumed to decrease the probability of an attack on the live system (unless the attackers discover the same bug independently before a patch is applied).
Ethereum introduces a new dimension to the responsible disclosure debate, as smart contracts can not be patched.
It is unclear whether it is ethical to fully disclose a vulnerability discovered in a smart contract, if developers can not fix it anyway\footnote{A technical response to this issue could be updateable contracts: users communicate with a proxy contract, which redirects their transactions to the latest version of the main contract. Such scheme assumes that the developers are honest and competent so that the latest update does not run away with everyone's money.}.
